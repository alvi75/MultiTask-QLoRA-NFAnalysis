{"id": "6367676c1a6d9265ec018204", "code": "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n  if (Objects.isEmpty(array1)) {\n    return array2;\n  }\n  if (Objects.isEmpty(array2)) {\n    return array1;\n  }\n  String[] newArr=new String[array1.length + array2.length];\n  System.arraycopy(array1,0,newArr,0,array1.length);\n  System.arraycopy(array2,0,newArr,array1.length,array2.length);\n  return newArr;\n}\n", "reference_summary": "Concatenate two string arrays into one."}
{"id": "636767a51a6d9265ec01859d", "code": "public boolean equals(final byte[] data,int offset,final int len){\n  final byte[] bytes=this.bytes;\n  if (len != bytes.length)   return false;\n  for (int i=0; i < len; ) {\n    if (bytes[i++] != data[offset++]) {\n      return false;\n    }\n  }\n  return true;\n}\n", "reference_summary": "Return true if the contents of the internal array bytes and the provided array data match."}
{"id": "6367676b1a6d9265ec0181e9", "code": "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n  for (int j=0; j < substring.length(); j++) {\n    int i=index + j;\n    if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {\n      return false;\n    }\n  }\n  return true;\n}\n", "reference_summary": "Return true if starting at the given index, the given string matches the given substring."}
{"id": "636766fa1a6d9265ec017796", "code": "public static Boolean[] toObject(final boolean[] array){\n  if (array == null) {\n    return null;\n  }\n else   if (array.length == 0) {\n    return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  final Boolean[] result=new Boolean[array.length];\n  for (int i=0; i < array.length; i++) {\n    result[i]=array[i] ? Boolean.TRUE : Boolean.FALSE;\n  }\n  return result;\n}\n", "reference_summary": "Convert an array of primitive booleans to objects."}
{"id": "636766fe1a6d9265ec01782a", "code": "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n  String value=constantUtf8Values[constantPoolEntryIndex];\n  if (value != null) {\n    return value;\n  }\n  int cpInfoOffset=cpInfoOffsets[constantPoolEntryIndex];\n  return constantUtf8Values[constantPoolEntryIndex]=readUtf(cpInfoOffset + 2,readUnsignedShort(cpInfoOffset),charBuffer);\n}\n", "reference_summary": "Read a CONSTANT_Utf8 constant pool entry in the classFileBuffer."}
{"id": "6367676d1a6d9265ec018229", "code": "public static String[] trimArrayElements(String[] array){\n  if (Objects.isEmpty(array)) {\n    return new String[0];\n  }\n  String[] result=new String[array.length];\n  for (int i=0; i < array.length; i++) {\n    String element=array[i];\n    result[i]=(element != null ? element.trim() : null);\n  }\n  return result;\n}\n", "reference_summary": "Trim each element in the given string array and return the resulting array."}
{"id": "636767631a6d9265ec018171", "code": "private boolean unlink(ListNodeImpl<E> node){\n  ListNodeImpl<E> prev=node.prev;\n  ListNodeImpl<E> next=node.next;\n  if (removeListNode(node)) {\n    if (size == 0) {\n      head=null;\n    }\n else {\n      link(prev,next);\n      if (head == node) {\n        head=next;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n", "reference_summary": "Remove the doubly circular linked list node.If success return true,otherwise return false."}
{"id": "636766861a6d9265ec01755a", "code": "public final MatchResult match(CharSequence uri){\n  if (uri == null || uri.length() == 0)   return (regexPattern == null) ? EMPTY_STRING_MATCH_RESULT : null;\n else   if (regexPattern == null)   return null;\n  Matcher m=regexPattern.matcher(uri);\n  if (!m.matches())   return null;\n  return (groupIndexes.length > 0) ? new GroupIndexMatchResult(m) : m;\n}\n", "reference_summary": "If the match between the url and the pattern occurs, return the match result. "}
{"id": "636767081a6d9265ec0179a2", "code": "private static boolean isAllZeros(String s){\n  if (s == null) {\n    return true;\n  }\n  for (int i=s.length() - 1; i >= 0; i--) {\n    if (s.charAt(i) != '0') {\n      return false;\n    }\n  }\n  return s.length() > 0;\n}\n", "reference_summary": "Check whether a character string is all consist of zero."}
{"id": "636767081a6d9265ec017989", "code": "public static boolean[] toPrimitive(final Boolean[] array){\n  if (array == null) {\n    return null;\n  }\n else   if (array.length == 0) {\n    return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n  }\n  final boolean[] result=new boolean[array.length];\n  for (int i=0; i < array.length; i++) {\n    result[i]=array[i].booleanValue();\n  }\n  return result;\n}\n", "reference_summary": "Convert the given Boolean array to primitives. "}
{"id": "6367676c1a6d9265ec01820b", "code": "public static String deleteAny(String inString,String charsToDelete){\n  if (!hasLength(inString) || !hasLength(charsToDelete)) {\n    return inString;\n  }\n  StringBuilder sb=new StringBuilder();\n  for (int i=0; i < inString.length(); i++) {\n    char c=inString.charAt(i);\n    if (charsToDelete.indexOf(c) == -1) {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}\n", "reference_summary": "Delete characters that exists in the intersection between two character strings of the first character string and return the first character string that is modified."}
{"id": "636767e11a6d9265ec018795", "code": "public boolean isCompatible(DataTable dataset){\n  final List<String> sortedKeys=dataset.sortedKeys(new HeatMap.KeyComparator(true));\n  long[] existedBuckets=new long[sortedKeys.size()];\n  for (int i=0; i < sortedKeys.size(); i++) {\n    String key=sortedKeys.get(i);\n    if (key.equals(Bucket.INFINITE_NEGATIVE)) {\n      existedBuckets[i]=Long.MIN_VALUE;\n    }\n else {\n      if (key.contains(\":\")) {\n        key=StringUtils.substringAfterLast(key,\":\");\n      }\n      existedBuckets[i]=Long.parseLong(key);\n    }\n  }\n  return Arrays.equals(buckets,existedBuckets);\n}\n", "reference_summary": "Check whether the existed buckets are the same as the buckets."}
{"id": "636767691a6d9265ec0181ac", "code": "public static String applyRelativePath(String path,String relativePath){\n  int separatorIndex=path.lastIndexOf(FOLDER_SEPARATOR);\n  if (separatorIndex != -1) {\n    String newPath=path.substring(0,separatorIndex);\n    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n      newPath+=FOLDER_SEPARATOR;\n    }\n    return newPath + relativePath;\n  }\n else {\n    return relativePath;\n  }\n}\n", "reference_summary": "Combine the substring before FOLDER_SEPARATOR of the given path with the given relative path to construct a new full file path, and return the full file path."}
{"id": "636767a41a6d9265ec018572", "code": "public long readRawVarint64() throws IOException {\n  int shift=0;\n  long result=0;\n  while (shift < 64) {\n    final byte b=readRawByte();\n    result|=(long)(b & 0x7F) << shift;\n    if ((b & 0x80) == 0) {\n      return result;\n    }\n    shift+=7;\n  }\n  throw ProtobufException.malformedVarint();\n}\n", "reference_summary": "Read raw varint."}
{"id": "636766f91a6d9265ec01777d", "code": "public static byte convertHexDigit(byte b){\n  if ((b >= '0') && (b <= '9'))   return (byte)(b - '0');\n  if ((b >= 'a') && (b <= 'f'))   return (byte)(b - 'a' + 10);\n  if ((b >= 'A') && (b <= 'F'))   return (byte)(b - 'A' + 10);\n  throw new IllegalArgumentException(\"!hex:\" + Integer.toHexString(0xff & b));\n}\n", "reference_summary": "Convert an ASCII encoded character to hex."}
{"id": "636766821a6d9265ec0174b6", "code": "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n  Class<?>[] result=null;\n  if (genericType instanceof ParameterizedType) {\n    ParameterizedType paramType=(ParameterizedType)genericType;\n    Type[] arguments=paramType.getActualTypeArguments();\n    result=new Class[arguments.length];\n    for (int i=0; i < arguments.length; i++)     result[i]=resolveClass(arguments[i],targetType);\n  }\n else   if (genericType instanceof TypeVariable) {\n    result=new Class[1];\n    result[0]=resolveClass(genericType,targetType);\n  }\n  return result;\n}\n", "reference_summary": "Resolve and return the arguments for the genericType using the type variable information for the targetType. "}
{"id": "636767431a6d9265ec017c88", "code": "private List<Integer> computeLowerBounds(List<K> keys){\n  List<Integer> keyLowerBounds=new ArrayList<>(keys.size());\n  for (  K key : keys) {\n    int lowerBound=0;\n    for (    Function<K,Integer> lowerBoundFunction : lowerBounds) {\n      lowerBound=Math.max(lowerBound,lowerBoundFunction.apply(key));\n    }\n    keyLowerBounds.add(lowerBound);\n  }\n  return keyLowerBounds;\n}\n", "reference_summary": "The type of key has several lower bounds conducted by different function, this function will return a list of the maximum lower bound of each key in the given list."}
{"id": "6367675c1a6d9265ec01805b", "code": "public void removeFromTreeEdgeList(){\n  for (int dir=0; dir < 2; dir++) {\n    if (prev[dir] != null) {\n      prev[dir].next[dir]=next[dir];\n    }\n else {\n      head[1 - dir].first[dir]=next[dir];\n    }\n    if (next[dir] != null) {\n      next[dir].prev[dir]=prev[dir];\n    }\n  }\n  head[0]=head[1]=null;\n}\n", "reference_summary": "Remove this edge from both doubly linked lists of the tree edges."}
{"id": "636767131a6d9265ec017b23", "code": "final void addLineNumber(final int lineNumber){\n  if (this.lineNumber == 0) {\n    this.lineNumber=(short)lineNumber;\n  }\n else {\n    if (otherLineNumbers == null) {\n      otherLineNumbers=new int[LINE_NUMBERS_CAPACITY_INCREMENT];\n    }\n    int otherLineNumberIndex=++otherLineNumbers[0];\n    if (otherLineNumberIndex >= otherLineNumbers.length) {\n      int[] newLineNumbers=new int[otherLineNumbers.length + LINE_NUMBERS_CAPACITY_INCREMENT];\n      System.arraycopy(otherLineNumbers,0,newLineNumbers,0,otherLineNumbers.length);\n      otherLineNumbers=newLineNumbers;\n    }\n    otherLineNumbers[otherLineNumberIndex]=lineNumber;\n  }\n}\n", "reference_summary": "Add the number of lines."}
{"id": "6367667f1a6d9265ec017457", "code": "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n  if (bb.limit() == 1 && (bb.get(0) & 0xFF) < 0x80) {\n    sb.append((char)bb.get(0));\n    return i + 2;\n  }\n else {\n    CharBuffer cb=UTF_8_CHARSET.decode(bb);\n    sb.append(cb);\n    return i + bb.limit() * 3 - 1;\n  }\n}\n", "reference_summary": "Decode octets to characters with UTF-8, append them to the given StringBuilder, and return the index to the next unchecked character."}
{"id": "636767611a6d9265ec018116", "code": "private Set<V> intersection(Set<V> set1,Set<V> set2){\n  Set<V> a;\n  Set<V> b;\n  if (set1.size() <= set2.size()) {\n    a=set1;\n    b=set2;\n  }\n else {\n    a=set2;\n    b=set1;\n  }\n  return a.stream().filter(b::contains).collect(Collectors.toSet());\n}\n", "reference_summary": "Return the intersection between two sets."}
{"id": "6367675d1a6d9265ec018082", "code": "Edge edgeToNext(){\n  Edge edge=prev.embedded.getFirst();\n  Node target=toExistingNode(current);\n  Node source=toExistingNode(prev);\n  if (edge.getOpposite(source) == target) {\n    return edge;\n  }\n else {\n    return prev.embedded.getLast();\n  }\n}\n", "reference_summary": "Return the edge connecting the previously returned node with the current node."}
{"id": "636767781a6d9265ec018250", "code": "public int decide(LoggingEvent event){\n  String msg=event.getRenderedMessage();\n  if (msg == null || stringToMatch == null)   return Filter.NEUTRAL;\n  if (msg.indexOf(stringToMatch) == -1) {\n    return Filter.NEUTRAL;\n  }\n else {\n    if (acceptOnMatch) {\n      return Filter.ACCEPT;\n    }\n else {\n      return Filter.DENY;\n    }\n  }\n}\n", "reference_summary": "Return a decision based on the message generated by the event and whether the given string is matched."}
{"id": "6367674a1a6d9265ec017da9", "code": "private void moveAllListNodes(DoublyLinkedList<E> list){\n  for (ListNodeIteratorImpl it=list.new ListNodeIteratorImpl(0); it.hasNext(); ) {\n    ListNodeImpl<E> node=it.nextNode();\n    assert node.list == list;\n    node.list=this;\n  }\n  size+=list.size;\n  list.size=0;\n  modCount++;\n  list.modCount++;\n}\n", "reference_summary": "Move the nodes of the given doubly linked list to a new list sequentially."}
{"id": "636767521a6d9265ec017ecc", "code": "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n  double newWidth=box.getWidth() / 2d;\n  double height=box.getHeight();\n  return Pair.of(Box2D.of(box.getMinX(),box.getMinY(),newWidth,height),Box2D.of(box.getMinX() + newWidth,box.getMinY(),newWidth,height));\n}\n", "reference_summary": "Divide a box into two equal boxes on the x axis."}
{"id": "6367676b1a6d9265ec0181df", "code": "public static boolean startsWithIgnoreCase(String str,String prefix){\n  if (str == null || prefix == null) {\n    return false;\n  }\n  if (str.startsWith(prefix)) {\n    return true;\n  }\n  if (str.length() < prefix.length()) {\n    return false;\n  }\n  String lcStr=str.substring(0,prefix.length()).toLowerCase();\n  String lcPrefix=prefix.toLowerCase();\n  return lcStr.equals(lcPrefix);\n}\n", "reference_summary": "Return true if the given string starts with the specified case-insensitive prefix, false otherwise."}
{"id": "6367670c1a6d9265ec017a2a", "code": "public static int[] toPrimitive(final Integer[] array){\n  if (array == null) {\n    return null;\n  }\n else   if (array.length == 0) {\n    return ArrayUtils.EMPTY_INT_ARRAY;\n  }\n  final int[] result=new int[array.length];\n  for (int i=0; i < array.length; i++) {\n    result[i]=array[i].intValue();\n  }\n  return result;\n}\n", "reference_summary": "Convert the given Integer array to primitives. "}
{"id": "6367675f1a6d9265ec0180cf", "code": "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n  for (  V v1 : vertices) {\n    for (    V v2 : vertices) {\n      if (!v1.equals(v2) && (graph.getEdge(v1,v2) == null)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n", "reference_summary": "Return true if the subgraph of the given graph induced by the given vertices is a clique, otherwise return false."}
{"id": "636766fe1a6d9265ec017838", "code": "public static char[] toPrimitive(final Character[] array){\n  if (array == null) {\n    return null;\n  }\n else   if (array.length == 0) {\n    return ArrayUtils.EMPTY_CHAR_ARRAY;\n  }\n  final char[] result=new char[array.length];\n  for (int i=0; i < array.length; i++) {\n    result[i]=array[i].charValue();\n  }\n  return result;\n}\n", "reference_summary": "Return a string which is consist of the values of elements in the given array."}
{"id": "636767691a6d9265ec0181a7", "code": "public static String trimLeadingCharacter(String str,char leadingCharacter){\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb=new StringBuilder(str);\n  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}\n", "reference_summary": "Trim all the characters which are equal to the given character and appear at the beginning of the given string,and return the trimmed string."}
{"id": "636766801a6d9265ec017487", "code": "public static String encodeTemplateNames(String s){\n  int i=s.indexOf('{');\n  if (i != -1)   s=s.replace(\"{\",\"%7B\");\n  i=s.indexOf('}');\n  if (i != -1)   s=s.replace(\"}\",\"%7D\");\n  return s;\n}\n", "reference_summary": "Encoding the given string by changing '{' and '}' to the specified character for each,return the string after encoding."}
{"id": "636767a21a6d9265ec018517", "code": "public final byte[] toByteArray(){\n  LinkedBuffer node=head;\n  int offset=0, len;\n  final byte[] buf=new byte[size];\n  do {\n    if ((len=node.offset - node.start) > 0) {\n      System.arraycopy(node.buffer,node.start,buf,offset,len);\n      offset+=len;\n    }\n  }\n while ((node=node.next) != null);\n  return buf;\n}\n", "reference_summary": "Copy bytes from LinkedBuffer and return."}
{"id": "636767861a6d9265ec01844c", "code": "public void removeAppender(String name){\n  if (name == null || appenderList == null)   return;\n  int size=appenderList.size();\n  for (int i=0; i < size; i++) {\n    if (name.equals(((Appender)appenderList.elementAt(i)).getName())) {\n      appenderList.removeElementAt(i);\n      break;\n    }\n  }\n}\n", "reference_summary": "Remove the appender by the given name from the list of appenders."}
{"id": "636767a81a6d9265ec0185fc", "code": "public int readTag() throws IOException {\n  if (!buffer.hasRemaining()) {\n    lastTag=0;\n    return 0;\n  }\n  final int tag=readRawVarint32();\n  if (tag >>> TAG_TYPE_BITS == 0) {\n    throw ProtobufException.invalidTag();\n  }\n  lastTag=tag;\n  return tag;\n}\n", "reference_summary": "Return a field tag, and if reach the EOF the tag will be zero."}
{"id": "6367670a1a6d9265ec0179e7", "code": "public Converter lookup(final Class<?> clazz){\n  Converter conv=(Converter)this.converters.get(clazz);\n  if (conv != null) {\n    return conv;\n  }\n  for (  Object regType : this.converters.keySet()) {\n    if (((Class<?>)regType).isAssignableFrom(clazz)) {\n      return (Converter)this.converters.get(regType);\n    }\n  }\n  return null;\n}\n", "reference_summary": "Check whether the specified converter exists in converters. "}
{"id": "636766821a6d9265ec0174d2", "code": "public static AtmosphereRequest wrap(HttpServletRequest request){\n  if (AtmosphereRequestImpl.class.isAssignableFrom(request.getClass())) {\n    return (AtmosphereRequestImpl)request;\n  }\n  Builder b=new Builder();\n  Enumeration<String> e=request.getAttributeNames();\n  String s;\n  while (e.hasMoreElements()) {\n    s=e.nextElement();\n    b.localAttributes.put(s,attributeWithoutException(request,s));\n  }\n  return b.request(request).build();\n}\n", "reference_summary": "Wrap an HttpServletRequest with the Builder."}
{"id": "636766f11a6d9265ec017663", "code": "public static boolean isSameLength(final double[] array1,final double[] array2){\n  if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n    return false;\n  }\n  return true;\n}\n", "reference_summary": "Return true if the length of array1 is the same as the length of array2 or both them are null, otherwise return false."}
{"id": "636766821a6d9265ec0174c9", "code": "private static File[] classPath(){\n  final String[] fileNames=System.getProperty(\"java.class.path\").split(File.pathSeparator);\n  final File[] files=new File[fileNames.length];\n  for (int i=0; i < files.length; ++i) {\n    files[i]=new File(fileNames[i]);\n  }\n  return files;\n}\n", "reference_summary": "Creates an array of the file type based on all file names in java.class.path and returns the array."}
{"id": "636767031a6d9265ec0178e6", "code": "public static byte[] toPrimitive(final Byte[] array){\n  if (array == null) {\n    return null;\n  }\n else   if (array.length == 0) {\n    return ArrayUtils.EMPTY_BYTE_ARRAY;\n  }\n  final byte[] result=new byte[array.length];\n  for (int i=0; i < array.length; i++) {\n    result[i]=array[i].byteValue();\n  }\n  return result;\n}\n", "reference_summary": "Convert an array of object Bytes to primitives, return null for a null input array."}
{"id": "636767e11a6d9265ec018781", "code": "@Override public void accept(final METRICS data){\n  final String id=data.id();\n  final METRICS existed=buffer.get(id);\n  if (existed == null) {\n    buffer.put(id,data);\n  }\n else {\n    final boolean isAbandoned=!existed.combine(data);\n    if (isAbandoned) {\n      buffer.remove(id);\n    }\n  }\n}\n", "reference_summary": "Accept the data into the buffer if its id does not exist in the buffer. "}
{"id": "636767a41a6d9265ec01856c", "code": "public static int computeUTF8Size(final CharSequence str,final int index,final int len){\n  int size=len;\n  for (int i=index; i < len; i++) {\n    final char c=str.charAt(i);\n    if (c < 0x0080)     continue;\n    if (c < 0x0800)     size++;\n else     size+=2;\n  }\n  return size;\n}\n", "reference_summary": "Compute the size of the utf8 string beginning at the specified  index  with the specified length."}
{"id": "636766a91a6d9265ec0175c4", "code": "private void pop(final String descriptor){\n  char firstDescriptorChar=descriptor.charAt(0);\n  if (firstDescriptorChar == '(') {\n    pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1);\n  }\n else   if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {\n    pop(2);\n  }\n else {\n    pop(1);\n  }\n}\n", "reference_summary": "Pop different value of type based on the first character of the given descriptor."}
{"id": "636767511a6d9265ec017eb6", "code": "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n  OuterFaceCirculator circulator=start.iterator(dir);\n  Node current=circulator.next();\n  while (current != stop && !predicate.test(current)) {\n    current=circulator.next();\n  }\n  return circulator;\n}\n", "reference_summary": "Find a circulator to the node that satisfies the Interface predicate."}
{"id": "636767041a6d9265ec01790f", "code": "public static Integer[] toObject(final int[] array){\n  if (array == null) {\n    return null;\n  }\n else   if (array.length == 0) {\n    return ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY;\n  }\n  final Integer[] result=new Integer[array.length];\n  for (int i=0; i < array.length; i++) {\n    result[i]=new Integer(array[i]);\n  }\n  return result;\n}\n", "reference_summary": "Return an array of Integer objects which are converted from an array of primitive ints."}
{"id": "6367670c1a6d9265ec017a35", "code": "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n  if (str == null || suffix == null) {\n    return str == null && suffix == null;\n  }\n  if (suffix.length() > str.length()) {\n    return false;\n  }\n  int strOffset=str.length() - suffix.length();\n  return str.regionMatches(ignoreCase,strOffset,suffix,0,suffix.length());\n}\n", "reference_summary": "Determines whether a character string ends with a specified suffix."}
{"id": "636767a61a6d9265ec0185b7", "code": "private static int digitValue(final char c){\n  if ('0' <= c && c <= '9') {\n    return c - '0';\n  }\n else   if ('a' <= c && c <= 'z') {\n    return c - 'a' + 10;\n  }\n else {\n    return c - 'A' + 10;\n  }\n}\n", "reference_summary": "Obtains the number corresponding to the character c."}
{"id": "636767611a6d9265ec018112", "code": "@Override protected V provideNextVertex(){\n  V v=super.provideNextVertex();\n  for (int i=path.size() - 1; i >= 0; --i) {\n    if (graph.containsEdge(path.get(i),v)) {\n      break;\n    }\n    path.remove(i);\n  }\n  path.add(v);\n  return v;\n}\n", "reference_summary": "Get next vertext from a graph."}
{"id": "636767791a6d9265ec01826d", "code": "public static String findAndSubst(String key,Properties props){\n  String value=props.getProperty(key);\n  if (value == null)   return null;\n  try {\n    return substVars(value,props);\n  }\n catch (  IllegalArgumentException e) {\n    LogLog.error(\"Bad option value [\" + value + \"].\",e);\n    return value;\n  }\n}\n", "reference_summary": "Find the value corresponding to key in props, then perform variable substitution on the found value. "}
{"id": "636766f81a6d9265ec017758", "code": "@Override public int hashCode(){\n  int hashCode=13 * (sort == INTERNAL ? OBJECT : sort);\n  if (sort >= ARRAY) {\n    for (int i=valueBegin, end=valueEnd; i < end; i++) {\n      hashCode=17 * (hashCode + valueBuffer.charAt(i));\n    }\n  }\n  return hashCode;\n}\n", "reference_summary": "Compute a hash code according to the type."}
{"id": "6367676b1a6d9265ec0181ee", "code": "public static String trimTrailingWhitespace(String str){\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb=new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n    sb.deleteCharAt(sb.length() - 1);\n  }\n  return sb.toString();\n}\n", "reference_summary": "Trim the end space of the str."}
{"id": "636767561a6d9265ec017f7c", "code": "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n  List<V> vertices=new ArrayList<>(tour.size() + 1);\n  MaskSubgraph<V,E> tourGraph=new MaskSubgraph<>(graph,v -> false,e -> !tour.contains(e));\n  new DepthFirstIterator<>(tourGraph).forEachRemaining(vertices::add);\n  return vertexListToTour(vertices,graph);\n}\n", "reference_summary": "Convert a set representation to a graph path."}
{"id": "636767871a6d9265ec01846d", "code": "public static void createConfigurationDirectory(){\n  String home=System.getProperty(\"user.home\");\n  String sep=System.getProperty(\"file.separator\");\n  File f=new File(home + sep + \"lf5\");\n  if (!f.exists()) {\n    try {\n      f.mkdir();\n    }\n catch (    SecurityException e) {\n      e.printStackTrace();\n    }\n  }\n}\n", "reference_summary": "Create the \"lf5\" directory in the Documents and Settings directory on Windows machines, or the user.home variable points on all other platforms."}
{"id": "636767691a6d9265ec0181aa", "code": "public static int nullSafeHashCode(long[] array){\n  if (array == null) {\n    return 0;\n  }\n  int hash=INITIAL_HASH;\n  int arraySize=array.length;\n  for (int i=0; i < arraySize; i++) {\n    hash=MULTIPLIER * hash + hashCode(array[i]);\n  }\n  return hash;\n}\n", "reference_summary": "Compute the hash code of the whole array, by accumulating the multiplication of each element hash code and the MULTIPLIER."}
{"id": "636767581a6d9265ec017fb4", "code": "private List<Integer> computeUpperBounds(List<K> keys){\n  List<Integer> keyUpperBounds=new ArrayList<>(keys.size());\n  for (  K key : keys) {\n    int upperBound=Integer.MAX_VALUE;\n    for (    Function<K,Integer> upperBoundFunction : upperBounds) {\n      upperBound=Math.min(upperBound,upperBoundFunction.apply(key));\n    }\n    keyUpperBounds.add(upperBound);\n  }\n  return keyUpperBounds;\n}\n", "reference_summary": "The type of key has several upper bounds conducted by different function, this function will return a list of the minimum upper bound of each key in the given list."}
{"id": "636767dd1a6d9265ec0186e5", "code": "public void addNewTarget(Channels channels,IConsumer consumer){\n  Group group=new Group(channels,consumer);\n  ArrayList<Group> newList=new ArrayList<Group>();\n  for (  Group target : consumeTargets) {\n    newList.add(target);\n  }\n  newList.add(group);\n  consumeTargets=newList;\n  size+=channels.size();\n}\n", "reference_summary": "Add the given target channels to the consumeTargets."}
{"id": "6367676c1a6d9265ec018220", "code": "public static String stripFilenameExtension(String path){\n  if (path == null) {\n    return null;\n  }\n  int extIndex=path.lastIndexOf(EXTENSION_SEPARATOR);\n  if (extIndex == -1) {\n    return path;\n  }\n  int folderIndex=path.lastIndexOf(FOLDER_SEPARATOR);\n  if (folderIndex > extIndex) {\n    return path;\n  }\n  return path.substring(0,extIndex);\n}\n", "reference_summary": "Return the path without the extension."}
{"id": "636767a41a6d9265ec018582", "code": "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n  if (buffer.start != buffer.offset)   throw new IllegalArgumentException(\"Buffer previously used and had not been reset.\");\n  final ProtobufOutput output=new ProtobufOutput(buffer);\n  schema.writeTo(output,message);\n  final int size=output.getSize();\n  ProtobufOutput.writeRawVarInt32Bytes(out,size);\n  final int msgSize=LinkedBuffer.writeTo(out,buffer);\n  assert size == msgSize;\n  return size;\n}\n", "reference_summary": "Use ProtobufOutput and the LinkedBuffer to write the message into the given OutputStream out, and return the message size."}
{"id": "6367672d1a6d9265ec017c73", "code": "public boolean shouldPrintMessage(int timestamp,String message){\n  if (messages.containsKey(message)) {\n    if (timestamp - messages.get(message) >= 10) {\n      messages.put(message,timestamp);\n      return true;\n    }\n else {\n      return false;\n    }\n  }\n else {\n    messages.put(message,timestamp);\n    return true;\n  }\n}\n", "reference_summary": "If the message does not exist in the dict messages, or it exists but the timestamp (seconds) difference is bigger than 10, put the message and timestamp into messages and return true, otherwise return false."}
{"id": "6367676b1a6d9265ec0181dd", "code": "public static int countOccurrencesOf(String str,String sub){\n  if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {\n    return 0;\n  }\n  int count=0;\n  int pos=0;\n  int idx;\n  while ((idx=str.indexOf(sub,pos)) != -1) {\n    ++count;\n    pos=idx + sub.length();\n  }\n  return count;\n}\n", "reference_summary": "Return the frequencies that the substring appears in the string."}
{"id": "6367676a1a6d9265ec0181d4", "code": "public static String[] addStringToArray(String[] array,String str){\n  if (Objects.isEmpty(array)) {\n    return new String[]{str};\n  }\n  String[] newArr=new String[array.length + 1];\n  System.arraycopy(array,0,newArr,0,array.length);\n  newArr[array.length]=str;\n  return newArr;\n}\n", "reference_summary": "Append a string to a string array."}
{"id": "6367677e1a6d9265ec01830f", "code": "public String format(LoggingEvent event){\n  if (sbuf.capacity() > MAX_CAPACITY) {\n    sbuf=new StringBuffer(BUF_SIZE);\n  }\n else {\n    sbuf.setLength(0);\n  }\n  PatternConverter c=head;\n  while (c != null) {\n    c.format(sbuf,event);\n    c=c.next;\n  }\n  return sbuf.toString();\n}\n", "reference_summary": "Format the buffered string with the pattern converter, and return the result."}
{"id": "636767df1a6d9265ec018744", "code": "protected List<TimeRange> buildTimeRanges(long start,long end){\n  if (start >= end) {\n    return null;\n  }\n  end+=1;\n  final List<TimeRange> timeRanges=new ArrayList<>();\n  do {\n    long batchEnd=Math.min(start + FETCH_DATA_DURATION,end);\n    timeRanges.add(new TimeRange(start,batchEnd));\n    start=batchEnd;\n  }\n while (start < end);\n  return timeRanges;\n}\n", "reference_summary": "Split time ranges to insure the start time and end time is small than FETCH_DATA_DURATION."}
{"id": "636767a31a6d9265ec018552", "code": "@Override public String readString() throws IOException {\n  final int size=readRawVarint32();\n  if (size <= (bufferSize - bufferPos) && size > 0) {\n    final String result=STRING.deser(buffer,bufferPos,size);\n    bufferPos+=size;\n    return result;\n  }\n else {\n    return STRING.deser(readRawBytes(size));\n  }\n}\n", "reference_summary": "Read string from a buffer."}
{"id": "636766ae1a6d9265ec0175d8", "code": "private String buildContentRange(){\n  Integer limit=drc.getLimit() == null ? getDefaultNumberPagination() - 1 : drc.getLimit();\n  Integer offset=drc.getOffset() == null ? 0 : drc.getOffset();\n  Long count=drc.getCount() == null ? 0 : drc.getCount();\n  return offset + \"-\" + (limit.equals(0) ? count - 1 : limit)+ \"/\"+ count;\n}\n", "reference_summary": "Return the string that contains the content range from offset to limit (when limit is zero,the upper bound will be count-1) and count."}
{"id": "636766fa1a6d9265ec0177a9", "code": "private void addInitializedType(final int abstractType){\n  if (initializations == null) {\n    initializations=new int[2];\n  }\n  int initializationsLength=initializations.length;\n  if (initializationCount >= initializationsLength) {\n    int[] newInitializations=new int[Math.max(initializationCount + 1,2 * initializationsLength)];\n    System.arraycopy(initializations,0,newInitializations,0,initializationsLength);\n    initializations=newInitializations;\n  }\n  initializations[initializationCount++]=abstractType;\n}\n", "reference_summary": "Add abstractType to the initializations variable."}
{"id": "6367676a1a6d9265ec0181cd", "code": "public static String trimLeadingWhitespace(String str){\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb=new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}\n", "reference_summary": "Trim the leading whitespaces in a string."}
{"id": "636767121a6d9265ec017b0a", "code": "private int parseEndOfLine(String headerPart,int end){\n  int index=end;\n  for (; ; ) {\n    int offset=headerPart.indexOf('\\r',index);\n    if (offset == -1 || offset + 1 >= headerPart.length()) {\n      throw new IllegalStateException(\"Expected headers to be terminated by an empty line.\");\n    }\n    if (headerPart.charAt(offset + 1) == '\\n') {\n      return offset;\n    }\n    index=offset + 1;\n  }\n}\n", "reference_summary": "Parse the header part starting from the given end position and return the index of the enter sequence."}
{"id": "636766821a6d9265ec0174bf", "code": "public static String capitalize(String name){\n  if (name == null || name.length() == 0) {\n    return name;\n  }\n  char chars[]=name.toCharArray();\n  chars[0]=Character.toUpperCase(chars[0]);\n  return new String(chars);\n}\n", "reference_summary": "Converts a name of the string type to a character array and converts the first letter to an uppercase letter."}
{"id": "636767021a6d9265ec0178b2", "code": "private void pop(final String descriptor){\n  char firstDescriptorChar=descriptor.charAt(0);\n  if (firstDescriptorChar == '(') {\n    pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1);\n  }\n else   if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {\n    pop(2);\n  }\n else {\n    pop(1);\n  }\n}\n", "reference_summary": "Pop the various value according to the first character of the descriptor."}
{"id": "6367677d1a6d9265ec0182fd", "code": "public static boolean toBoolean(String value,boolean dEfault){\n  if (value == null)   return dEfault;\n  String trimmedVal=value.trim();\n  if (\"true\".equalsIgnoreCase(trimmedVal))   return true;\n  if (\"false\".equalsIgnoreCase(trimmedVal))   return false;\n  return dEfault;\n}\n", "reference_summary": "Check whether a string is true or false after ignore cases and trim the whitespaces at both ends. "}
{"id": "636767861a6d9265ec018440", "code": "public void abbreviate(final int nameStart,final StringBuffer buf){\n  int i=count;\n  for (int pos=buf.indexOf(\".\",nameStart); pos != -1; pos=buf.indexOf(\".\",pos + 1)) {\n    if (--i == 0) {\n      buf.delete(nameStart,pos + 1);\n      break;\n    }\n  }\n}\n", "reference_summary": "The given name can be split into several substrings by \".\", and abbreviate the name in the buf by deleting the first count substrings."}
{"id": "636766a81a6d9265ec017595", "code": "final ByteVector put11(final int byteValue1,final int byteValue2){\n  int currentLength=length;\n  if (currentLength + 2 > data.length) {\n    enlarge(2);\n  }\n  byte[] currentData=data;\n  currentData[currentLength++]=(byte)byteValue1;\n  currentData[currentLength++]=(byte)byteValue2;\n  length=currentLength;\n  return this;\n}\n", "reference_summary": "Put two bytes into a byte vector called data."}
{"id": "636766fa1a6d9265ec0177a4", "code": "public static Double[] toObject(final double[] array){\n  if (array == null) {\n    return null;\n  }\n else   if (array.length == 0) {\n    return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  final Double[] result=new Double[array.length];\n  for (int i=0; i < array.length; i++) {\n    result[i]=new Double(array[i]);\n  }\n  return result;\n}\n", "reference_summary": "Return an array of Double objects which are converted from an array of primitive doubles."}
{"id": "636766fa1a6d9265ec01779c", "code": "private String parseToken(final char[] terminators){\n  char ch;\n  i1=pos;\n  i2=pos;\n  while (hasChar()) {\n    ch=chars[pos];\n    if (isOneOf(ch,terminators)) {\n      break;\n    }\n    i2++;\n    pos++;\n  }\n  return getToken(false);\n}\n", "reference_summary": "Parses out a token until any of the given terminators is encountered and then return the token."}
{"id": "636767e01a6d9265ec018755", "code": "private Map<String,Object> buildContent(JsonObject jsonObject){\n  Map<String,Object> content=new HashMap<>();\n  content.put(\"msg_type\",jsonObject.get(\"msg_type\").getAsString());\n  if (jsonObject.get(\"ats\") != null) {\n    String ats=jsonObject.get(\"ats\").getAsString();\n    String text=jsonObject.get(\"content\").getAsJsonObject().get(\"text\").getAsString();\n    List<String> collect=Arrays.stream(ats.split(\",\")).map(String::trim).collect(Collectors.toList());\n    for (    String userId : collect) {\n      text+=\"<at user_id=\\\"\" + userId + \"\\\"></at>\";\n    }\n    jsonObject.get(\"content\").getAsJsonObject().addProperty(\"text\",text);\n  }\n  content.put(\"content\",jsonObject.get(\"content\").getAsJsonObject());\n  return content;\n}\n", "reference_summary": "Put the \"content\" from the  jsonObject to the content."}
{"id": "636766f91a6d9265ec01776e", "code": "@Override public void write(final byte b[],final int off,final int len) throws IOException {\n  if (off < 0 || off > b.length || len < 0 || off + len > b.length || off + len < 0) {\n    throw new IndexOutOfBoundsException();\n  }\n else   if (len == 0) {\n    return;\n  }\n  if (this.count + len > this.buf.length) {\n    this.encodePendingBytes(false);\n  }\n  System.arraycopy(b,off,this.buf,this.count,len);\n  this.count+=len;\n}\n", "reference_summary": "Write bytes of length len from a byte array."}
{"id": "636767461a6d9265ec017d0e", "code": "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n  List<Integer> suffixSum=new ArrayList<>(Collections.nCopies(bounds.size(),0));\n  long sum=0;\n  for (int i=bounds.size() - 1; i >= 0; i--) {\n    suffixSum.set(i,(int)Math.min(Integer.MAX_VALUE,sum));\n    sum+=bounds.get(i);\n  }\n  return Pair.of(suffixSum,sum);\n}\n", "reference_summary": "Return a pair of the list of suffix sum and the sum of all elements of bounds."}
{"id": "6367670b1a6d9265ec017a00", "code": "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n  if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n    return false;\n  }\n  return true;\n}\n", "reference_summary": "Check whether the length of the given two byte arrays is the same."}
{"id": "636766fe1a6d9265ec017821", "code": "protected void appendDetail(StringBuffer buffer,String fieldName,byte[] array){\n  buffer.append(arrayStart);\n  for (int i=0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    appendDetail(buffer,fieldName,array[i]);\n  }\n  buffer.append(arrayEnd);\n}\n", "reference_summary": "Append a byte array to a buffer."}
{"id": "6367670b1a6d9265ec017a0f", "code": "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n  if (StringUtils.isEmpty(str) || searchStrArray == null || searchStrArray.isEmpty()) {\n    return false;\n  }\n  for (  String item : searchStrArray) {\n    if (containsIgnoreCase(str,item)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "reference_summary": "Check whether str contains elements in searchStrArray. "}
{"id": "636766aa1a6d9265ec0175ce", "code": "int visitFrameStart(final int offset,final int numLocal,final int numStack){\n  int frameLength=3 + numLocal + numStack;\n  if (currentFrame == null || currentFrame.length < frameLength) {\n    currentFrame=new int[frameLength];\n  }\n  currentFrame[0]=offset;\n  currentFrame[1]=numLocal;\n  currentFrame[2]=numStack;\n  return 3;\n}\n", "reference_summary": "Init a currentFrame with the given offset, numLocal and numStack, return 3 finally."}
{"id": "636767a31a6d9265ec01854f", "code": "private void checkIfPackedField() throws IOException {\n  if (packedLimit == 0 && WireFormat.getTagWireType(lastTag) == WIRETYPE_LENGTH_DELIMITED) {\n    final int length=readRawVarint32();\n    if (length < 0)     throw ProtobufException.negativeSize();\n    this.packedLimit=getTotalBytesRead() + length;\n  }\n}\n", "reference_summary": "Check if the field should be packed,if so,read the field and update the internal state. "}
{"id": "6367675f1a6d9265ec0180d3", "code": "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n  Map<V,V> fMap=CollectionUtil.newHashMapWithExpectedSize(graph.vertexSet().size());\n  Map<V,V> bMap=CollectionUtil.newHashMapWithExpectedSize(graph.vertexSet().size());\n  for (  V v : graph.vertexSet()) {\n    fMap.put(v,v);\n    bMap.put(v,v);\n  }\n  return new IsomorphicGraphMapping<>(fMap,bMap,graph,graph);\n}\n", "reference_summary": "Compute and return an identity automorphism for the given graph."}
{"id": "636766851a6d9265ec01751b", "code": "private static char decodeHexNibble(final char c){\n  if ('0' <= c && c <= '9') {\n    return (char)(c - '0');\n  }\n else   if ('a' <= c && c <= 'f') {\n    return (char)(c - 'a' + 10);\n  }\n else   if ('A' <= c && c <= 'F') {\n    return (char)(c - 'A' + 10);\n  }\n else {\n    return Character.MAX_VALUE;\n  }\n}\n", "reference_summary": "Convert a hexadecimal number to binary and return its character type."}
{"id": "636767151a6d9265ec017b6b", "code": "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n  if (str == null || prefix == null) {\n    return str == null && prefix == null;\n  }\n  if (prefix.length() > str.length()) {\n    return false;\n  }\n  return str.regionMatches(ignoreCase,0,prefix,0,prefix.length());\n}\n", "reference_summary": "Return true if the given string has the specified prefix with optional cases which can be ignored, or both string and prefix are null.Otherwise return false."}
{"id": "6367670a1a6d9265ec0179f1", "code": "public static Short[] toObject(final short[] array){\n  if (array == null) {\n    return null;\n  }\n else   if (array.length == 0) {\n    return ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY;\n  }\n  final Short[] result=new Short[array.length];\n  for (int i=0; i < array.length; i++) {\n    result[i]=new Short(array[i]);\n  }\n  return result;\n}\n", "reference_summary": "Convert an array of primitive shorts to objects."}
{"id": "6367671a1a6d9265ec017c15", "code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n  if (length + byteLength > data.length) {\n    enlarge(byteLength);\n  }\n  if (byteArrayValue != null) {\n    System.arraycopy(byteArrayValue,byteOffset,data,length,byteLength);\n  }\n  length+=byteLength;\n  return this;\n}\n", "reference_summary": "Put an array of bytes into this byte vector, enlarge the byte vector automatically if necessary."}
{"id": "636766fc1a6d9265ec0177ef", "code": "static String[] toNoNullStringArray(Object[] array){\n  ArrayList<String> list=new ArrayList<String>(array.length);\n  for (int i=0; i < array.length; i++) {\n    Object e=array[i];\n    if (e != null) {\n      list.add(e.toString());\n    }\n  }\n  return (String[])list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n}\n", "reference_summary": "Return a new array of strings converted from the elements which are not null of the given array, if the size of the array is zero, it will throw an exception."}
{"id": "6367667d1a6d9265ec01741d", "code": "public static Type resolveBound(TypeVariable<?> typeVariable){\n  Type[] bounds=typeVariable.getBounds();\n  if (bounds.length == 0)   return Unknown.class;\n  Type bound=bounds[0];\n  if (bound instanceof TypeVariable)   bound=resolveBound((TypeVariable<?>)bound);\n  return bound == Object.class ? Unknown.class : bound;\n}\n", "reference_summary": "Resolve the class of the first bound for the typeVariable recursively, return Unknown.class if it can't be resolved."}
{"id": "636767601a6d9265ec0180e2", "code": "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n  List<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList=new ArrayList<>();\n  for (  E edge : graph.edgeSet()) {\n    V source=graph.getEdgeSource(edge);\n    V target=graph.getEdgeTarget(edge);\n    if (source != target) {\n      List<Set<V>> edgeSeparators=findSeparators(graph,edge);\n      globalSeparatorList.addAll(reformatSeparatorList(edgeSeparators,edge));\n    }\n  }\n  return globalSeparatorList;\n}\n", "reference_summary": "Select an edge which isn't a circle in the graph,compute the list of the minimal separators in the neighborhood of the edge and put the pair of list and edge into the return list."}
{"id": "636766ff1a6d9265ec01784b", "code": "public static boolean isDigits(String str){\n  if ((str == null) || (str.length() == 0)) {\n    return false;\n  }\n  for (int i=0; i < str.length(); i++) {\n    if (!Character.isDigit(str.charAt(i))) {\n      return false;\n    }\n  }\n  return true;\n}\n", "reference_summary": "Check whether a character string is a dight. "}
{"id": "636767691a6d9265ec0181a6", "code": "public static String[] split(String toSplit,String delimiter){\n  if (!hasLength(toSplit) || !hasLength(delimiter)) {\n    return null;\n  }\n  int offset=toSplit.indexOf(delimiter);\n  if (offset < 0) {\n    return null;\n  }\n  String beforeDelimiter=toSplit.substring(0,offset);\n  String afterDelimiter=toSplit.substring(offset + delimiter.length());\n  return new String[]{beforeDelimiter,afterDelimiter};\n}\n", "reference_summary": "Split the given string toSplit at the first occurrence of the given delimiter,and return two substrings that don't include the delimiter."}
{"id": "6367667f1a6d9265ec01745d", "code": "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n  String rawPath=u.getRawPath();\n  if (rawPath != null && rawPath.length() > 0 && rawPath.charAt(0) == '/') {\n    rawPath=rawPath.substring(1);\n  }\n  return decodePath(rawPath,decode);\n}\n", "reference_summary": "Decode the raw path."}
{"id": "636767031a6d9265ec0178ef", "code": "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n  if (array != null) {\n    int arrayLength=Array.getLength(array);\n    Object newArray=Array.newInstance(array.getClass().getComponentType(),arrayLength + 1);\n    System.arraycopy(array,0,newArray,0,arrayLength);\n    return newArray;\n  }\n  return Array.newInstance(newArrayComponentType,1);\n}\n", "reference_summary": "Copy the given array and add a default value at the end."}
{"id": "6367676b1a6d9265ec0181e2", "code": "public static Object findFirstMatch(Collection source,Collection candidates){\n  if (isEmpty(source) || isEmpty(candidates)) {\n    return null;\n  }\n  for (  Object candidate : candidates) {\n    if (source.contains(candidate)) {\n      return candidate;\n    }\n  }\n  return null;\n}\n", "reference_summary": "Returns the first element in candidates that matches the source."}
{"id": "636767dc1a6d9265ec0186be", "code": "static long compressTimeBucket(long timeBucket,int dayStep){\n  if (dayStep > 1) {\n    DateTime time=TIME_BUCKET_FORMATTER.parseDateTime(\"\" + timeBucket);\n    int days=Days.daysBetween(DAY_ONE,time).getDays();\n    int groupBucketOffset=days % dayStep;\n    return Long.parseLong(time.minusDays(groupBucketOffset).toString(TIME_BUCKET_FORMATTER));\n  }\n else {\n    return timeBucket;\n  }\n}\n", "reference_summary": "Follow the dayStep to reformat the time bucket with TIME_BUCKET_FORMATTER. "}
{"id": "6367677f1a6d9265ec018347", "code": "public synchronized void send(final String message){\n  Iterator ce=connections.iterator();\n  for (Iterator e=writers.iterator(); e.hasNext(); ) {\n    ce.next();\n    PrintWriter writer=(PrintWriter)e.next();\n    writer.print(message);\n    if (writer.checkError()) {\n      ce.remove();\n      e.remove();\n    }\n  }\n}\n", "reference_summary": "Send a message to each of the connections in telnet-friendly output."}
{"id": "636767021a6d9265ec0178bf", "code": "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n  String string=value.toString();\n  if (string.length() == 0) {\n    return BeanUtils.getDefaultValue(type);\n  }\n else {\n    return string.charAt(0);\n  }\n}\n", "reference_summary": "If the length of the value string is 0, the default type is returned. "}
{"id": "636766ff1a6d9265ec017842", "code": "public static double[] toPrimitive(final Double[] array){\n  if (array == null) {\n    return null;\n  }\n else   if (array.length == 0) {\n    return ArrayUtils.EMPTY_DOUBLE_ARRAY;\n  }\n  final double[] result=new double[array.length];\n  for (int i=0; i < array.length; i++) {\n    result[i]=array[i].doubleValue();\n  }\n  return result;\n}\n", "reference_summary": "If the length of the array is 0, return EMPTY_DOUBLE_ARRAY. "}
